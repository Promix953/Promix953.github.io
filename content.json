[{"title":"Node 项目注意点","date":"2017-04-12T18:42:37.000Z","path":"2017/Node项目注意点/","text":"随着语言，工具，运行环境，开发方式的不断变化，你的 node 项目当然也需要不断的与时俱进，那么我们就依次来看看需要注意哪些问题吧。 现在开始使用 ES2015 箭头函数 模板字符串 rest参数，扩展运算符(spread),函数默认值 变量的解构赋值 generator 和 promises maps，sets 和 symbols 在服务器端的推荐使用新的 node 解释器支持的语法，或者可以用babel作为compile层（具体做法参考脚手架） 123// 从 express's req.query 解构 特定参数 ?page=2&amp;size=10&amp;word=测试let &#123;page, size, word&#125; = req.query; 异步函数支持回调惯例和Promise新写法过去，当Promise没有成为Node默认搭载的语法时，推荐模块通过导出 error-first callback 的接口形式。但是现在通常需要支持两种形式： 1234567891011121314const fs = require('fs')function readPackage(callback=noop) &#123; return new Promise((resolve, reject)=&gt;&#123; fs.readFile('./package.json', (err, data)=&gt;&#123; if(err) &#123; reject(err) return callback(err) &#125; resolve(data) return callback(null, data) &#125;) &#125;)&#125; 异步模式过去很长时间，在 node 中一般有两种方式来管理异步流：callback回调和 streams 流前者可以用辅助我们异步操作的 async 类库后者可以用through, bl or highland 这些类库但是随着 es6的 generator和promise的到来，甚至es7的 await/async 内建关键字的到来，情况变了。 详细请看 异步JavaScript的演进 错误处理完善合理的错误处理让你的服务更加强健。知道何时crash，然后是仅仅catch后忽略，还是记下调用栈打入log后重试，甚至是需要重启？我们通常需要区别对待 programmer error, operational errors:前者直接重启（事实上在开发阶段就该发现，并且线上通过 logger 定位），因为程序员写的bug，如果不及时重启会导致应用的状态难以推演，从而发生更多更大的问题而后者，通常不是bug，而是没有考虑全的case。如外部请求超时了，外部依赖的数据库连不上了，甚至所在运行的机器磁盘写满了，要访问写入的文件暂时不存在了。这些case一般需要在程序里加上特定的fallback/polyfill 来处理。如对于超时的重试几次，对于不存在的文件先试着创建新文件，对于总是塞满磁盘的log，通过logstash和logrotate去处理。 回调中的错误处理error-first 约定的callback，始终记得在函数开始检查第一个err是否存在，然后进行合适的处理（当然也可以通过 next(e) 传入到调用栈的最后统一处理） Promise中的错误处理始终记得在 promise 调用链的最后加上 catch 来处理异常 使用标准的 JavaScript 代码风格过去我们使用 jslint, jshint, jscs 来作为我们的代码风格检查工具，但是随着 es6 的流行，还有一些新的习惯的养成，我们推荐使用 eslint 工具，同时配合 eslint-plugin-standard 插件 12345&#123; \"plugins\": [ \"standard\" ],&#125; Web 应用开发的十二条军规来自于 Rails 社区的血泪经验，但是大部分也是适用于我们Node项目 (一些实践可能在新的docker部署下会有小调整） 一份基准代码Codebase，多份部署deploy 显示声明和隔离依赖 在配置放在环境中 把外部后端服务当做附加资源 严格分离构建和运行环境 以一个或多个无状态进程运行应用 通过端口绑定(Port binding)来提供服务 通过进程模型进行扩展 快速启动和优雅终止可最大化健壮性 尽可能的保持开发，预发布，线上环境相同 把日志当作事件流 后台管理任务当作一次性进程运行 始终用 npm init 开始新项目通过 npm init 来初始化你的node项目，通过promt 确定你的项目名称，开发者信息等（当然你可以通过 –yes 旗标来跳过）Tip: 主要你应该总是显示指名你的node engines 版本（node -v），确保你的开发环境，测试环境和线上环境是用同一版本的 node. 12345&#123; \"engines\": &#123; \"node\": \"6.10.2\" &#125;&#125; 文件名始终小写因为在 OSX 和 Windows 系统中，MyClass.js 和 myclass.js 没有任何区别，Linux 则会区分。所以为了你写的代码在不同操作系统是可移植的（在使用 require 来引入模块确保语句是一致明确的），所以始终保持小写 - my-class.js 智能的.npmrc 和正确的版本管理做法默认上， npm 在安装新的依赖的modules，默认不会加入到package.json中。同时，modules的版本号不是严格锁死的（^尖角号来确保大版本保持一致）这样会造成一些问题，如在发布时才发现没有把依赖写入到package.json中，造成线上缺少必要的模块，线上部署发现用的不是相同的modules，导致莫名其妙的问题和大量的depricated warning警告。 所以安装新依赖推荐这样的写法：npm install foobar --save --save-exact或者写入.npmrc 这样下次 npm install 就不会犯错啦 123$ npm config set save=true$ npm config set save-exact=true$ cat ~/.npmrc 如果如果希望更灵活的依赖控制，可以通过 npm shrinkwrap 命令生成 npm-shrinkwrap.json 加入到版本库中，这样在build环境构建也能保证版本统一。 及时更新依赖上面的版本锁死让你面对依赖模块的时候更加从容，但是要记得保持定期更新依赖，从而获得修复bug和性能优化功能完善的更新。可以每周利用 npm outdated 或 ncu 工具包 选择合适的数据库大部分新的noder，在选择数据库，喜欢选择Mongodb。它的确很不错，但是 Mongodb 不是唯一的选择、你应该根据你的应用场景来选择： 你的数据是否结构化的 你的数据操作是否要支持事务 你数据是否需要持久化 从而选择不同的数据库：如 PostgreSQL， Redis, LevelDB 等等 监控你的应用程序你要对你的线上应用的运行状况了如指掌（CPU，Memory，日志等），对一些突发情况需要及时获得通知。很多开源项目和SaaS产品都提供完善强大的监控服务，如Zabbix, Collectd, ElasticSearch 和 Logstash. 甚至结合Cabot给微信公众号发消息提醒等等 使用构建系统现在的JavaScript的工具链有大量的选择： Grunt, Gulp, Webpack等。譬如在团队里，我们选择 Webpack 来辅助前端开发，gulp用来处理大量其他的自动化任务（你的shell脚本也可以通过gulp-shell集成进来）。当然我们也推荐使用 vanilla build （尤其你可以结合 npm lifecycle hooks 完成很多事） NPM 生命周期钩子提供了很好的钩子来使得一些task实现的很优雅，脚手架大量使用了这样的技巧 1234567&quot;postinstall&quot;: &quot;bower install &amp;&amp; grunt build&quot;,&quot;postinstall&quot;: &quot;if $BUILD_ASSETS; then npm run build-assets; fi&quot;,&quot;build-assets&quot;: &quot;bower install &amp;&amp; grunt build&quot;# 如果脚本变复杂可以单独文件：&quot;postinstall&quot;: &quot;scripts/postinstall.sh” (sh 脚本中会自动可以访问到 ./node_modules/.bin 中的命令，因为该路径被加入到 $PATH) 管好垃圾回收v8默认使用 lazy 和 贪婪的 GC. 有时候等到1.5GB 自由才去回收未被使用的内存 (所以有时候内存涨不是因为泄露还是node’s usual lazy behavior) 所以你不想自己的node应用经常把服务器的内存占满（或者你不得不调整，因为你的机器可用内存没那么多），试着使用下面的命令/proc 文件来启动 node 服务（推荐写在 .pm2config 中，正如脚手架推荐的） 1web: node --optimize_for_size --max_old_space_size=920 --gc_interval=100 server.js 使用长期支持的 Node.js 版本如果你需要在不同项目中工作，并且不同项目用的node版本还不一样，可以使用 node version manager(nvm) 使用语义化的版本号通过三段版本数来确保把兼容性声明好。 major.minor.patch 这样的格式，不同级别的升级对API更新的要求也是不一样的。可以通过semantic-release 来让版本升级更加自动化 持续学习和跟上潮流JavaScript 和 Node.js 社区异常活跃，的确是件好事。每周都有新的工具新的理念的加入，让我们始终保持热情和技术的提升（警惕自己变成跟风狗，要取色和了解每个新东西背后的不变的本质），不要待在自己的蜜罐中，要动手做试验和学习。以下资料： Node.js Weekly Newsletter Microservice Weekly Newsletter Changelog Weekly - for Open-Source news 参考 How to Become a Better Node.js Developer 10 habits of a happy node hacker 2016 Web 服务开发的十二条军规","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://promix.me/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://promix.me/tags/Node-js/"}]},{"title":"JS深拷贝碰到的问题","date":"2017-04-12T10:18:22.000Z","path":"2017/JS深拷贝碰到的问题/","text":"js的数据类型有：Null Undefined Boolean Number Array String Object 之分，es6后又增加了Symbol，其中分为2大类：基本数据类型和对象类型，同时产生了相应的2个传值方式：赋值和引用； 基本数据类型的深拷贝通过JSON1JSON.parse(JSON.stringify(obj)) 通过简单函数1234567function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c;&#125; 引用类型深拷贝引用类型细分 基本的JS对象：正则，函数，对象，数组等之分 其他JS内置的Date，Error，Math等 浏览器内置的window，document等 严格来说，这些对象赋值时都是要考虑的，但常见的对象内部存放的数据类型不会涵盖的这么全面，但也需要考虑：正则，函数，对象，数组，Dete，Dom 数据类型的识别办法1var type=Object.prototype.toString.call(Obj).split(/[\\[\\s\\]]/)[2] 通过识别type可以确认数据的类型，然后分别针对Array，Object做不同的处理 1234567891011121314151617181920let obj1 = &#123; a: 11, b: 'bb', c: new Date(), d: function aa () &#123;return 2&#125;, e:[1,2,3], f:new Error('error'), g:document.body, h:new RegExp(/[111]/)&#125;function deepCopy (obj) &#123; var type = Object.prototype.toString.call(obj).split(/[\\[\\s\\]]/)[2]; let temp = type === 'Array' ? [] : type=='Object'? &#123;&#125;:obj; if(type=='Array' || type=='Object')&#123; for (let val in obj) &#123; temp[val] = typeof obj[val] == 'object' ? deepCopy(obj[val]) : obj[val] &#125; &#125; return temp&#125; 如上，实现了深拷贝 但深拷贝还有一个坑要填那就是循环赋值问题；回到前面的 123456789101112131415161718192021222324let obj1 = &#123; a: 11, b: 'bb', c: new Date(), d: function aa () &#123;return 2&#125;, e:[1,2,3], f:new Error('error'), g:document.body, h:new RegExp(/[111]/), &#125;obj1.g=obj1 deepCopy(obj1)//Uncaught RangeError: Maximum call stack size exceeded at RegExp.[Symbol.split] () at String.split (native) at deepCopy (:12:50) at deepCopy (:16:47) at deepCopy (:16:47) at deepCopy (:16:47) at deepCopy (:16:47) at deepCopy (:16:47) at deepCopy (:16:47) at deepCopy (:16:47) 这是就会出现堆栈溢出的错误。 重复引用会有什么问题例子1： 1234var obj=&#123; a:1&#125;obj.b=obj 例子2： 1o1=&#123;a:1&#125;;o2=&#123;a:o1&#125;;o3=&#123;a:o2&#125;;o1.a=o3 这时去做深拷贝，会陷入无限递归。 怎么解决对象本身就是树形结构，可以用一个数组来保存当前枝叶链上的所有object，如果下层枝叶又引用上层的obj，那就直接赋值，而不是采用递归，从而打破无限递归的深渊。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var deepCopyArray = [], deepType=&#123; Array:[], Object:&#123;&#125; &#125;, deepTypeValue=&#123; Array:true, Object:true &#125;;function getType(obj)&#123; return Object.prototype.toString.call(obj).split(/[\\[\\s\\]]/)[2];&#125;function deepCopy(obj) &#123; let type =getType(obj); let data = type === 'Array' ? [] : type=='Object'? &#123;&#125;:obj; if(deepType[type])&#123; for (let val in obj) &#123; let value=obj[val]; let subType=getType(value); if(deepType[subType]) &#123; deepCopyArray = []; deepCopyArray.push(obj); deepCopyArray.push(value); data[val] = deepCopyFn(value) &#125;else&#123; data[val]=value; &#125; &#125; &#125; return data&#125;function deepCopyFn(obj)&#123; let type =getType(obj); let data = type === 'Array' ? [] : type=='Object'? &#123;&#125;:obj; if(deepType[type])&#123; for (let val in obj) &#123; let value=obj[val]; let subType=getType(value); let flag=false; if(deepType[subType]) &#123; for (let i = 0; i &lt; deepCopyArray.length; i++) &#123; if (deepCopyArray[i] === value) &#123; flag = true; break; &#125; &#125; if (!flag) &#123; deepCopyArray.push(value); data[val] = deepCopyFn(value); &#125;else&#123; data[val]=value; &#125; &#125;else&#123; data[val]=value; &#125; &#125; &#125; return data&#125; 基本解决深拷贝问题，虽然不完美，但已经可以使用了。测试代码： 12345678910111213141516171819202122232425262728293031323334353637var o1 = &#123;a: 1&#125;, o2 = &#123;b: o1&#125;, o3 = &#123;c: o2&#125;;var obj1 = &#123; a: 11, b: 'bb', c: new Date(), d: function aa() &#123; return 2 &#125;, e: [1, 2, 3], f: new Error('error'), g: document.body, h: new RegExp(/[111]/), i: o1, j: o2, k: o3, l: &#123;a: o1&#125;&#125;;obj1.m = obj1;obj1.n = &#123; a: o1, b: &#123; b: obj1.d, c: obj1.i, d: obj1.l &#125;&#125;;o1.b = obj1;obj2 = deepCopy(obj1)console.log(obj1.a==obj2.a)console.log(obj1.h==obj2.h)console.log(obj1.i==obj2.i)console.log('obj1.i.b----'+(obj1.i.b==obj2.i.b));console.log(obj1.k==obj2.k)console.log(obj1.k.c==obj2.k.c)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://promix.me/tags/JavaScript/"}]},{"title":"妙用Javascript中apply、call、bind","date":"2017-04-11T16:52:52.000Z","path":"2017/妙用Javascript中apply、call、bind/","text":"apply、call用法的简单示例1234567891011121314151617function fruits() &#123;&#125;fruits.prototype = &#123; color: \"red\", say: function() &#123; console.log(\"My color is \" + this.color); &#125;&#125;var apple = new fruits;apple.say(); //My color is redbanana = &#123; color: \"yellow\"&#125;apple.say.call(banana); //My color is yellowapple.say.apply(banana); //My color is yellow apply 、 call 区别注意apply传递的参数是数组，而call是按参数顺序传递 123456var func = function(arg1, arg2) &#123;&#125;;func.call(this, arg1, arg2); func.apply(this, [arg1, arg2]) apply 、 call 用法示例 数组之间追加 1234var array1 = [12 , \"foo\" , &#123;name \"Joe\"&#125; , -2458]; var array2 = [\"Doe\" , 555 , 100]; Array.prototype.push.apply(array1, array2); /* array1 值为 [12 , \"foo\" , &#123;name \"Joe\"&#125; , -2458 , \"Doe\" , 555 , 100] */ 获取数组中的最大值和最小值 123var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(Math, numbers), //458 maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458 验证是否是数组（前提是toString()方法没有被重写过） 123functionisArray(obj)&#123; returnObject.prototype.toString.call(obj) === '[object Array]' ;&#125; 类（伪）数组使用数组方法 1var domNodes = Array.prototype.slice.call(document.getElementsByTagName(\"*\")); 一道面试题目1234567891011121314151617181920212223//使用 log 代理 console.logfunction log(msg) &#123; console.log(msg);&#125;log(1);log(1,2);//优雅的方法function log()&#123; console.log.apply(console, arguments);&#125;;log(1);log(1,2);//添加一个 (app) 前缀function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift('(app)'); console.log.apply(console, args);&#125;; bind 用法简单示例12345678910111213141516171819202122// 正常情况下使用变量保存 this 值var foo = &#123; bar : 1, eventBind: function()&#123; var _this = this ; $('.someClass').on('click',function(event) &#123; /* Act on the event */ console.log(_this.bar); //1 &#125;); &#125;&#125;// 使用 bind 进行函数绑定var foo = &#123; bar : 1, eventBind: function()&#123; $('.someClass').on('click',function(event) &#123; /* Act on the event */ console.log(this.bar); //1 &#125;.bind(this)); &#125;&#125; 1234567891011varfoo = &#123; x: 3&#125; var bar = function()&#123; console.log(this.x);&#125; bar(); // undefinedvar func = bar.bind(foo);func(); // 3 apply、call、bind 比较12345678910111213var obj = &#123; x: 81,&#125;;var foo = &#123; getX: function() &#123; return this.x; &#125;&#125;console.log(foo.getX.bind(obj)()); //81console.log(foo.getX.call(obj)); //81console.log(foo.getX.apply(obj)); //81","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://promix.me/tags/JavaScript/"}]},{"title":"nodejs_stream_手册","date":"2017-04-10T18:22:52.000Z","path":"2017/nodejs_stream_手册/","text":"nodejs stream 手册写在前面的话: 如果你正在学习Nodejs，那么流一定是一个你需要掌握的概念。如果你想成为一个Node高手，那么流一定是武功秘籍中不可缺少的一个部分。关于流这个主题，由Node高手substack带来的stream-handbook绝对是经典入门读物之一，其在Github上的star数量已经超过了4500个，足以见其权威程度。本文下面的内容将参考自substack的这篇文章。 引子 在编写代码时，我们应该有一些方法将程序像连接水管一样连接起来 – 当我们需要获取一些数据时，可以去通过”拧”其他的部分来达到目的。这也应该是IO应有的方式。 – Doug McIlroy. October 11, 1964 从早先的unix开始，stream便开始进入了人们的视野，在过去的几十年的时间里，它被证明是一种可依赖的编程方式，它可以将一个大型的系统拆成一些很小的部分，并且让这些部分之间完美地进行合作。在unix中，我们可以使用|符号来实现流。在node中，node内置的stream模块已经被多个核心模块使用，同时也可以被用户自定义的模块使用。和unix类似，node中的流模块的基本操作符叫做.pipe()，同时你也可以使用一个后压机制来应对那些对数据消耗较慢的对象。 在node中，流可以帮助我们将事情的重点分为几份，因为使用流可以帮助我们将实现接口的部分分割成一些连续的接口，这些接口都是可重用的。接着，你可以将一个流的输出口接到另一个流的输入口，然后使用使用一些库来对流实现高级别的控制。 对于小型程序设计(small-program design)以及unix哲学来说，流都是一个重要的组成部分，但是除此之外还有一些重要的事情值得我们思考。永远要记得：十鸟在森林不如一鸟在手里。 为什么应该使用流在node中，I/O都是异步的，所以在和硬盘以及网络的交互过程中会涉及到传递回调函数的过程。你之前可能会写出这样的代码： 123456789var http = require('http');var fs = require('fs');var server = http.createServer(function (req, res) &#123; fs.readFile(__dirname + '/data.txt',function (err, data) &#123; res.end(data); &#125;);&#125;);server.listen(8000); 上面的这段代码并没有什么问题，但是在每次请求时，我们都会把整个data.txt文件读入到内存中，然后再把结果返回给客户端。想想看，如果data.txt文件非常大，在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。 其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。 所幸的是，(req,res)参数都是流对象，这意味着我们可以使用一种更好的方法来实现上面的需求： 12345678var http = require('http');var fs = require('fs');var server = http.createServer(function (req, res) &#123; var stream = fs.createReadStream(__dirname + '/data.txt'); stream.pipe(res);&#125;);server.listen(8000); 在这里，.pipe()方法会自动帮助我们监听data和end事件。上面的这段代码不仅简洁，而且data.txt文件中每一小段数据都将源源不断的发送到客户端。 除此之外，使用.pipe()方法还有别的好处，比如说它可以自动控制后端压力，以便在客户端连接缓慢的时候node可以将尽可能少的缓存放到内存中。 想要将数据进行压缩？我们可以使用相应的流模块完成这项工作! 123456789var http = require('http');var fs = require('fs');var oppressor = require('oppressor');var server = http.createServer(function (req, res) &#123; var stream = fs.createReadStream(__dirname + '/data.txt'); stream.pipe(oppressor(req)).pipe(res);&#125;);server.listen(8000); 通过上面的代码，我们成功的将发送到浏览器端的数据进行了gzip压缩。我们只是使用了一个oppressor模块来处理这件事情。 一旦你学会使用流api，你可以将这些流模块像搭乐高积木或者像连接水管一样拼凑起来，从此以后你可能再也不会去使用那些没有流API的模块获取和推送数据了。 流模块基础在node中，一共有五种类型的流：readable,writable,transform,duplex以及classic pipe无论哪一种流，都会使用.pipe()方法来实现输入和输出。 .pipe()函数很简单，它仅仅是接受一个源头src并将数据输出到一个可写的流dst中： 1src.pipe(dst) .pipe(dst)将会返回dst因此你可以链式调用多个流: 1a.pipe(b).pipe(c).pipe(d) 上面的代码也可以等价为： 123a.pipe(b);b.pipe(c);c.pipe(d); 这和你在unix中编写流代码很类似： 1a | b | c | d 只不过此时你是在node中编写而不是在shell中！ readable流Readable流可以产出数据，你可以将这些数据传送到一个writable，transform或者duplex流中，只需要调用pipe()方法: 1readableStream.pipe(dst) 创建一个readable流现在我们就来创建一个readable流！ 12345678var Readable = require('stream').Readable;var rs = new Readable;rs.push('beep ');rs.push('boop\\n');rs.push(null);rs.pipe(process.stdout); 下面运行代码： 12$ node read0.jsbeep boop 在上面的代码中rs.push(null)的作用是告诉rs输出数据应该结束了。 需要注意的一点是我们在将数据输出到process.stdout之前已经将内容推送进readable流rs中，但是所有的数据依然是可写的。 这是因为在你使用.push()将数据推进一个readable流中时，一直要到另一个东西来消耗数据之前，数据都会存在一个缓存中。 然而，在更多的情况下，我们想要的是当需要数据时数据才会产生，以此来避免大量的缓存数据。 我们可以通过定义一个._read函数来实现按需推送数据: 12345678910var Readable = require('stream').Readable;var rs = Readable();var c = 97;rs._read = function () &#123; rs.push(String.fromCharCode(c++)); if (c &gt; 'z'.charCodeAt(0)) rs.push(null);&#125;;rs.pipe(process.stdout); 代码的运行结果如下所示: 12$ node read1.jsabcdefghijklmnopqrstuvwxyz 在这里我们将字母a到z推进了rs中，但是只有当数据消耗者出现时，数据才会真正实现推送。 _read函数也可以获取一个size参数来指明消耗者想要读取多少比特的数据，但是这个参数是可选的。 需要注意到的是你可以使用util.inherit()来继承一个Readable流。 为了说明只有在数据消耗者出现时，_read函数才会被调用，我们可以将上面的代码简单的修改一下： 12345678910111213141516171819var Readable = require('stream').Readable;var rs = Readable();var c = 97 - 1;rs._read = function () &#123; if (c &gt;= 'z'.charCodeAt(0)) return rs.push(null); setTimeout(function () &#123; rs.push(String.fromCharCode(++c)); &#125;, 100);&#125;;rs.pipe(process.stdout);process.on('exit', function () &#123; console.error('\\n_read() called ' + (c - 97) + ' times');&#125;);process.stdout.on('error', process.exit); 运行上面的代码我们可以发现如果我们只请求5比特的数据，那么_read只会运行5次： 123$ node read2.js | head -c5abcde_read() called 5 times 在上面的代码中，setTimeout很重要，因为操作系统需要花费一些时间来发送程序结束信号。 另外,process.stdout.on(&#39;error&#39;,fn)处理器也很重要，因为当head不再关心我们的程序输出时，操作系统将会向我们的进程发送一个SIGPIPE信号，此时process.stdout将会捕获到一个EPIPE错误。 上面这些复杂的部分在和操作系统相关的交互中是必要的，但是如果你直接和node中的流交互的话，则可有可无。 如果你创建了一个readable流，并且想要将任何的值推送到其中的话，确保你在创建流的时候指定了objectMode参数,Readable({ objectMode: true })。 消耗一个readable流大部分时候，将一个readable流直接pipe到另一种类型的流或者使用through或者concat-stream创建的流中，是一件很容易的事情。但是有时我们也会需要直接来消耗一个readable流。 1234process.stdin.on('readable', function () &#123; var buf = process.stdin.read(); console.dir(buf);&#125;); 代码运行结果如下所示： 12345$ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume0.js &lt;Buffer 61 62 63 0a&gt;&lt;Buffer 64 65 66 0a&gt;&lt;Buffer 67 68 69 0a&gt;null 当数据可用时，readable事件将会被触发，此时你可以调用.read()方法来从缓存中获取这些数据。 当流结束时，.read()将返回null，因为此时已经没有更多的字节可以供我们获取了。 你也可以告诉.read()方法来返回n个字节的数据。虽然所有核心对象中的流都支持这种方式，但是对于对象流来说这种方法并不可用。 下面是一个例子，在这里我们制定每次读取3个字节的数据： 1234process.stdin.on('readable', function () &#123; var buf = process.stdin.read(3); console.dir(buf);&#125;); 运行上面的例子，我们将获取到不完整的数据: 1234$ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume1.js &lt;Buffer 61 62 63&gt;&lt;Buffer 0a 64 65&gt;&lt;Buffer 66 0a 67&gt; 这是因为多余的数据都留在了内部的缓存中，因此这个时候我们需要告诉node我们还对剩下的数据感兴趣，我们可以使用.read(0)来完成这件事： 12345process.stdin.on('readable', function () &#123; var buf = process.stdin.read(3); console.dir(buf); process.stdin.read(0);&#125;); 到现在为止我们的代码和我们所期望的一样了！ 12345$ (echo abc; sleep 1; echo def; sleep 1; echo ghi) | node consume2.js &lt;Buffer 61 62 63&gt;&lt;Buffer 0a 64 65&gt;&lt;Buffer 66 0a 67&gt;&lt;Buffer 68 69 0a&gt; 我们也可以使用.unshift()方法来放置多余的数据。 使用unshift()方法能够放置我们进行不必要的缓存拷贝。在下面的代码中我们将创建一个分割新行的可读解析器: 12345678910111213141516var offset = 0;process.stdin.on('readable', function () &#123; var buf = process.stdin.read(); if (!buf) return; for (; offset &lt; buf.length; offset++) &#123; if (buf[offset] === 0x0a) &#123; console.dir(buf.slice(0, offset).toString()); buf = buf.slice(offset + 1); offset = 0; process.stdin.unshift(buf); return; &#125; &#125; process.stdin.unshift(buf);&#125;); 代码的运行结果如下所示： 1234567891011$ tail -n +50000 /usr/share/dict/american-english | head -n10 | node lines.js 'hearties''heartiest''heartily''heartiness''heartiness\\'s''heartland''heartland\\'s''heartlands''heartless''heartlessly' 当然，已经有很多这样的模块比如split来帮助你完成这件事情，你完全不需要自己写一个。 writable流一个writable流指的是只能流进不能流出的流: 1src.pipe(writableStream) 创建一个writable流只需要定义一个._write(chunk,enc,next)函数，你就可以将一个readable流的数据释放到其中： 12345678var Writable = require('stream').Writable;var ws = Writable();ws._write = function (chunk, enc, next) &#123; console.dir(chunk); next();&#125;;process.stdin.pipe(ws); 代码运行结果如下所示： 123$ (echo beep; sleep 1; echo boop) | node write0.js &lt;Buffer 62 65 65 70 0a&gt;&lt;Buffer 62 6f 6f 70 0a&gt; 第一个参数，chunk代表写进来的数据。 第二个参数enc代表编码的字符串，但是只有在opts.decodeString为false的时候你才可以写一个字符串。 第三个参数，next(err)是一个回调函数，使用这个回调函数你可以告诉数据消耗者可以写更多的数据。你可以有选择性的传递一个错误对象error，这时会在流实体上触发一个emit事件。 在从一个readable流向一个writable流传数据的过程中，数据会自动被转换为Buffer对象，除非你在创建writable流的时候制定了decodeStrings参数为false,Writable({decodeStrings: false})。 如果你需要传递对象，需要指定objectMode参数为true，Writable({ objectMode: true })。 向一个writable流中写东西如果你需要向一个writable流中写东西，只需要调用.write(data)即可。 1process.stdout.write('beep boop\\n'); 为了告诉一个writable流你已经写完毕了，只需要调用.end()方法。你也可以使用.end(data)在结束前再写一些数据。 12345678var fs = require('fs');var ws = fs.createWriteStream('message.txt');ws.write('beep ');setTimeout(function () &#123; ws.end('boop\\n');&#125;, 1000); 运行结果如下所示: 123$ node writing1.js $ cat message.txtbeep boop 如果你需要调整内部缓冲区大小，那么需要在创建可写流对象时设置highWaterMark。在调用.write()方法返回false时，说明写入的数据大小超过了该值。 为了避免读写速率不匹配而造成内存上涨，可以监听drain事件，等待可写流内部缓存被清空再继续写入。 transform流你可以将transform流想象成一个流的中间部分，它可以读也可写，但是并不保存数据，它只负责处理流经它的数据。 duplex流Duplex流是一个可读也可写的流，就好像一个电话，可以接收也可以发送语音。一个rpc交换是一个duplex流的最好的例子。如果你看到过下面这样的代码： 1234567891011121314151617181920212223242526272829303132333435a.pipe(b).pipe(a```)那么你需要处理的就是一个duplex流对象。## classic流 Classic流是一个古老的接口，最早出现在node 0.4中。虽然现在不怎么用，但是我们最好还是来了解一下它的工作原理。无论何时，只要一个流对象注册了一个`data`监听器，它就会自动的切换到`classic`模式，并且根据旧API的方式运行。### classic readable流 Classic readable流只是一个事件发射器，当有数据消耗者出现时发射`emit`事件，当输出数据完毕时发射`end`事件。我们可以同构检查`stream.readable`来检查一个classic流对象是否可读。 下面是一个简单的readable流对象的例子，程序的运行结果将会输出`A`到`J`：``` jsvar Stream = require('stream');var stream = new Stream;stream.readable = true;var c = 64;var iv = setInterval(function () &#123; if (++c &gt;= 75) &#123; clearInterval(iv); stream.emit('end'); &#125; else stream.emit('data', String.fromCharCode(c));&#125;, 100);stream.pipe(process.stdout); 运行结果如下所示: 12$ node classic0.jsABCDEFGHIJ 为了从一个classic readable流中读取数据，你可以注册data和end监听器。下面是一个使用旧readable流方式从process.stdin中读取数据的例子: 123456process.stdin.on('data', function (buf) &#123; console.log(buf);&#125;);process.stdin.on('end', function () &#123; console.log('__END__');&#125;); 运行结果如下所示: 1234$ (echo beep; sleep 1; echo boop) | node classic1.js &lt;Buffer 62 65 65 70 0a&gt;&lt;Buffer 62 6f 6f 70 0a&gt;__END__ 需要注意的一点是当你在一个流对象上注册了一个data监听器，你就将这个流放在了兼容模式下，此时你不能使用两个stream2的api。 如果你自己创建流对象，永远不要绑定data和end监听器。如果你需要和旧版本的流兼容，最好使用第三方库来实现.pipe()方法。 例如，你可以使用through模块来避免显式的使用data和end监听器: 123456789var through = require('through');process.stdin.pipe(through(write, end));function write (buf) &#123; console.log(buf);&#125;function end () &#123; console.log('__END__');&#125; 程序运行结果如下所示: 1234$ (echo beep; sleep 1; echo boop) | node through.js &lt;Buffer 62 65 65 70 0a&gt;&lt;Buffer 62 6f 6f 70 0a&gt;__END__ 你也可以使用concat-stream模块来将整个流的内容缓存起来: 1234var concat = require('concat-stream');process.stdin.pipe(concat(function (body) &#123; console.log(JSON.parse(body));&#125;)); 程序运行结果如下所示: 12$ echo '&#123;\"beep\":\"boop\"&#125;' | node concat.js &#123; beep: 'boop' &#125; Classic readable流拥有.pause()和.resume()逻辑来暂停一个流，但是这都是可选的。如果你想要使用.pause()和.resume()方法，你应该使用through模块来帮助你处理缓存。 classic writable流Classic writable流非常简单。其中只定义了.write(buf)，.end(buf)，以及.desctory()方法。其中.end(buf)的参数buf是可选参数，但是一般来说node程序员还是喜欢使用.end(buf)这种写法。 接下来读什么 node核心stream模块文档 你可以使用readable-stream)模块来确保你的stream2代码兼容node 0.8及其之前的代码。在你npm install readable-stream之后直接require(&#39;readable-stream&#39;)而不要require(&#39;stream&#39;)。 本文参考自stream-handbook，原文地址https://github.com/substack/stream-handbook","tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"https://promix.me/tags/NodeJs/"}]},{"title":"JS的严格模式","date":"2017-04-10T18:09:24.000Z","path":"2017/JS的严格模式/","text":"优点 消除JS语法的一些不合理、不严谨之处、减少一些怪异的行为 消除代码运行的一些不安全之处，保证代码运行的安全 提高编译器效率，增加运行效率 为未来新版本的JS做好铺垫 详细 全局变量必须显示声明 123456789101112131415161718 \"use strict\"; v = 1; // 报错，v未声明 ``` * 静态绑定，属性和方法到底归属哪个对象，在编译阶段就确定。提高了编译器的效率 ``` js //禁止使用with语句 因为无法在编译时确定属性归属的对象 \"use strict\"; var v = 1; with (o)&#123; // 语法错误 v = 2; &#125; // 创建了eval作用域正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 \"use strict\"; var x = 2; console.info(eval(\"var x = 5; x\")); // 5 console.info(x); // 2 增强的安全措施 禁止this关键字指向全局对象 123456// 使用构造函数时 如果忘了加new，this不再指向全局对象，而是报错function f() &#123; \"ues strict\"; this.a = 1;&#125;;f(); // 报错，this未定义 禁止在函数内部遍历调用栈 123456function f1() &#123; \"use strict\"; f1.caller; // error f1.arguments; // error &#125; 禁止删除变量 1234567891011// 严格模式下无法删除变量。只用configurable设置为true的对象属性，才能被删除\"use strict\";var x;detele x; //errorvar r = Object.create(null, &#123;'x': &#123; value: 1, configureable: true&#125;&#125;)delete o.x; // delete success 显示报错 1234567891011121314151617181920212223242526272829303132// 正常模式下。对一个对象的只读属性进行赋值，不会报错，会默默的失败，严格模式下，会报错\"use strict\"; var o = &#123;&#125;;Object.defineProperty(o, \"v\", &#123; value: 1, writable: false&#125;);o.v = 2; // error// 严格模式下，对一个使用getter方法读取的属性进行赋值，会报错\"use strict\";var o = &#123; get v() &#123;return 1;&#125;&#125;o.v = 2; // error//严格模式下，对禁止扩展的对象添加新属性，会报错。\"use strict\";var o = &#123;&#125;; Object.preventExtensions(o);o.v = 1; // error //严格模式下，删除一个不可删除的属性，会报错 \"use strict\"; delete Object.prototype; // error 重名错误，对象不能有重名的参数，对象不能有重名的属性 禁止八进制表示法 arguments对象的限制 123456789101112131415// 不允许对arguments赋值// arguments不再追踪参数的变化function f(a) &#123; a = 2; return [a, arguments[0]];&#125; f(1) // 正常模式 [2, 2]function f(a) &#123; \"use strict\"; a = 2; return [a, arguments[0]];&#125; f(1) // 严格模式下 [2, 1]// 禁止使用arguments.callee 函数必须声明在顶层 12345678910// 严格模式只允许在全局作用域或函数作用域的顶层声明函数，也就是说，不允许在非函数的代码块内声明函数\"use strict\";if(true) &#123; function f() &#123; // ...&#125; // error&#125;for(...) &#123; function f() &#123; // ... &#125; // error&#125; 保留字，使用保留字会报错�","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://promix.me/tags/JavaScript/"}]},{"title":"关于 JavaScript 的数组随机排序","date":"2017-04-09T19:47:44.000Z","path":"2017/关于 JavaScript 的数组随机排序/","text":"JavaScript 开发中有时会遇到要将一个数组随机排序（shuffle）的需求，一个常见的写法是这样： 12345function shuffle(arr) &#123; arr.sort(function () &#123; return Math.random() - 0.5; &#125;);&#125; 或者使用更简洁的 ES6 的写法： 123function shuffle(arr) &#123; arr.sort(() =&gt; Math.random() - 0.5);&#125; 我也曾经经常使用这种写法，不久前才意识到，这种写法是有问题的，它并不能真正地随机打乱数组。 问题看下面的代码，我们生成一个长度为 10 的数组[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’, ‘h’, ‘i’, ‘j’]，使用上面的方法将数组乱序，执行多次后，会发现每个元素仍然有很大机率在它原来的位置附近出现。 12345678910let n = 10000;let count = (new Array(10)).fill(0); for (let i = 0; i &lt; n; i ++) &#123; let arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']; arr.sort(() =&gt; Math.random() - 0.5); count[arr.indexOf('a')]++;&#125; console.log(count); 在 Node.JS 6 中执行，输出[ 2891, 2928, 1927, 1125, 579, 270, 151, 76, 34, 19 ]（带有一定随机性，每次结果都不同，但大致分布应该一致），即进行 10000 次排序后，字母’a’（数组中的第一个元素）有约 2891 次出现在第一个位置、2928 次出现在第二个位置，与之对应的只有 19 次出现在最后一个位置。类似地，我们可以算出字母’f’（数组中的第六个元素）在各个位置出现的分布为[ 312, 294, 579, 1012, 1781, 2232, 1758, 1129, 586, 317 ]。如果排序真的是随机的，那么每个元素在每个位置出现的概率都应该一样，实验结果各个位置的数字应该很接近，而不应像现在这样明显地集中在原来位置附近。因此，我们可以认为，使用形如arr.sort(() =&gt; Math.random() - 0.5)这样的方法得到的并不是真正的随机排序。另外，需要注意的是上面的分布仅适用于数组长度不超过 10 的情况，如果数组更长，比如长度为 11，则会是另一种分布。比如： 1234567891011let a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']; // 长度为11let n = 10000;let count = (new Array(a.length)).fill(0); for (let i = 0; i &lt; n; i ++) &#123; let arr = [].concat(a); arr.sort(() =&gt; Math.random() - 0.5); count[arr.indexOf('a')]++;&#125; console.log(count); 在 Node.JS 6 中执行，结果为[ 785, 819, 594, 679, 941, 1067, 932, 697, 624, 986, 1876 ]。分布不同的原因是 v8 引擎中针对短数组和长数组使用了不同的排序方法（下面会讲）。可以看到，两种算法的结果虽然不同，但都明显不够均匀。国外有人写了一个Shuffle算法可视化的页面，在上面可以更直观地看到使用arr.sort(() =&gt; Math.random() - 0.5)的确是很不随机的。 探索看了一下ECMAScript中关于Array.prototype.sort(comparefn)的标准，其中并没有规定具体的实现算法，但是提到一点： Calling comparefn(a,b) always returns the same value v when given a specific pair of values a and b as its two arguments. 也就是说，对同一组a、b的值，comparefn(a, b)需要总是返回相同的值。而上面的() =&gt; Math.random() - 0.5（即(a, b) =&gt; Math.random() - 0.5）显然不满足这个条件。翻看v8引擎数组部分的源码，注意到它出于对性能的考虑，对短数组使用的是插入排序，对长数组则使用了快速排序，至此，也就能理解为什么() =&gt; Math.random() - 0.5并不能真正随机打乱数组排序了。（有一个没明白的地方：源码中说的是对长度小于等于 22 的使用插入排序，大于 22 的使用快排，但实际测试结果显示分界长度是 10。） 解决方案知道问题所在，解决方案也就比较简单了。 方案一既然(a, b) =&gt; Math.random() - 0.5的问题是不能保证针对同一组a、b每次返回的值相同，那么我们不妨将数组元素改造一下，比如将每个元素i改造为： 1234let new_i = &#123; v: i, r: Math.random()&#125;; 即将它改造为一个对象，原来的值存储在键v中，同时给它增加一个键r，值为一个随机数，然后排序时比较这个随机数： 1arr.sort((a, b) =&gt; a.r - b.r); 完整代码如下： 12345678910111213141516function shuffle(arr) &#123; let new_arr = arr.map(i =&gt; (&#123;v: i, r: Math.random()&#125;)); new_arr.sort((a, b) =&gt; a.r - b.r); arr.splice(0, arr.length, ...new_arr.map(i =&gt; i.v));&#125; let a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];let n = 10000;let count = (new Array(a.length)).fill(0); for (let i = 0; i &lt; n; i ++) &#123; shuffle(a); count[a.indexOf('a')]++;&#125; console.log(count); 一次执行结果为：[ 1023, 991, 1007, 967, 990, 1032, 968, 1061, 990, 971 ]。多次验证，同时查看shuffle(arr)函数结果的可视化分布，可以看到，这个方法可以认为足够随机了。 方案二（Fisher–Yates shuffle）需要注意的是，上面的方法虽然满足随机性要求了，但在性能上并不是很好，需要遍历几次数组，还要对数组进行splice等操作。考察Lodash 库中的 shuffle 算法，注意到它使用的实际上是Fisher–Yates 洗牌算法，这个算法由 Ronald Fisher 和 Frank Yates 于 1938 年提出，然后在 1964 年由 Richard Durstenfeld 改编为适用于电脑编程的版本。用伪代码描述如下： 1234-- To shuffle an array a of n elements (indices 0..n-1):for i from n−1 downto 1 do j ← random integer such that 0 ≤ j ≤ i exchange a[j] and a[i] 一个实现如下（ES6）： 1234567function shuffle(arr) &#123; let i = arr.length; while (i) &#123; let j = Math.floor(Math.random() * i--); [arr[j], arr[i]] = [arr[i], arr[j]]; &#125;&#125; 或者对应的 ES5 版本： 123456789function shuffle(arr) &#123; var i = arr.length, t, j; while (i) &#123; j = Math.floor(Math.random() * i--); t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125;&#125; 小结如果要将数组随机排序，千万不要再用(a, b) =&gt; Math.random() - 0.5这样的方法。目前而言，Fisher–Yates shuffle 算法应该是最好的选择。–Yates shuffle 算法应该是最好的选择。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://promix.me/tags/JavaScript/"}]},{"title":"Gox_简单实在的Go平台交叉编译工具","date":"2017-04-08T21:40:59.000Z","path":"2017/Gox_简单实在的Go平台交叉编译工具/","text":"Gox 是一个简单的，不花俏的Go平台交叉编译工具，它的用处就和标准的 go build 一样。Gox 会并行地为多种平台编译。Gox 同时也提供了一套交叉编译工具链。Gox 项目地址：https://github.com/mitchellh/gox 安装为了安装 Gox，请使用 go get。我们已经为版本打上了标签，所以可以随便切换标签进行编译：1234$ go get github.com/mitchellh/gox...$ gox -h... 用法在你使用 Gox 之前，你必须先有一套交叉编译工具链。Gox 可以自动帮你完成这个。你需要做的只是运行(每次更新 Go 都要这样做这步)：1$ gox -build-toolchain ... 当你完成这个，你可以已经准备好进行交叉编译了。如果你知道怎么去使用 go build, 那么你也知道怎么去使用 Gox 了。例如，编译当前的项目，无需提供参数，只需要调用 gox。Gox 就会根据 CPU 的数量并行地为各个平台编译：1234567891011121314151617$ gox Number of parallel builds: 4--&gt; darwin/386: github.com/mitchellh/gox--&gt; darwin/amd64: github.com/mitchellh/gox--&gt; linux/386: github.com/mitchellh/gox--&gt; linux/amd64: github.com/mitchellh/gox--&gt; linux/arm: github.com/mitchellh/gox--&gt; freebsd/386: github.com/mitchellh/gox--&gt; freebsd/amd64: github.com/mitchellh/gox--&gt; openbsd/386: github.com/mitchellh/gox--&gt; openbsd/amd64: github.com/mitchellh/gox--&gt; windows/386: github.com/mitchellh/gox--&gt; windows/amd64: github.com/mitchellh/gox--&gt; freebsd/arm: github.com/mitchellh/gox--&gt; netbsd/386: github.com/mitchellh/gox--&gt; netbsd/amd64: github.com/mitchellh/gox--&gt; netbsd/arm: github.com/mitchellh/gox--&gt; plan9/386: github.com/mitchellh/gox 或者，你只想编译某个项目和子项目：1$ gox ./... ... 或者，你想仅仅为 linux 编译：1$ gox -os=\"linux\" ... 或者，你仅仅只想为 64 位的 linux 编译：1$ gox -osarch=\"linux/amd64\" ... 还有更多的选项，可以通过 gox -h 查看帮助。 和其他交叉编译工具的比较非常感谢这些工具为我们提供了更多的选择，它们为 go 平台的交叉编译工具提供做了很多方面的贡献. Dave Cheney的交叉编译器： Gox 可以为多种平台编译，所以也能容易地运行在各种 Go 支持的平台上。但Dave的那个需要一个 shell 来运行。Gox 支持并行地编译，但 Dave 的只是按顺序地编译。Gox 也能非常方便地使用的内置的 arch 系统的内置过滤工具。 goxc：它是一个功能丰富的工具，能编译系统项目，上传二进制文件，产生下载页面等；相较之下，Gox 在交叉编译二元文件方面稍稍弱些。但 Gox 能并行地编译项目，而 goxc 不能。Gox 也没有强制指定编译二元文件时输出结果的格式。","tags":[{"name":"Golang","slug":"Golang","permalink":"https://promix.me/tags/Golang/"}]},{"title":"JS中浮点数运算不精准","date":"2017-04-03T21:51:41.000Z","path":"2017/JS中浮点数运算不精准/","text":"Javascript采用了IEEE-745浮点数表示法，这是一种二进制表示法，可以精确地表示分数，比如1/2，1/8，1/1024。遗憾的是，我们常用的分数都是十进制分数1/10，1/100等，二进制浮点数表示法并不能精确的表示类似0.1这样的简单的数字。所以会有js中浮点数运算不精准的问题出现，我们一般会重写js的四则运算。下面主要看看解决js中浮点数运算不精准的具体方法。下面先看看几个JS四则运算的例子，你一定会很惊讶和自己想想的结果不太一样。1234js加法：9.3+0.3;//结果为9.600000000000001js加法：9.3-0.7;//结果为8.600000000000001js乘法：7*0.8;//结果为5.6000000000000005js除法：9.3/0.3;//结果为31.000000000000004 下面看看具体的解决办法，思路就是把浮点数先转换为整数再运算，运算后再对结果转换为小数：JS加法函数12345678function accAdd(arg1,arg2)&#123; var r1,r2,m; try&#123;r1=arg1.toString().split(\".\")[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(\".\")[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)) return (arg1\\*m+arg2\\*m)/m&#125; JS减法函数1234567891011function Subtr(arg1,arg2)&#123; var r1,r2,m,n; try&#123;r1=arg1.toString().split(\".\")[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(\".\")[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)); //动态控制精度长度 n=(r1&gt;=r2)?r1:r2; return ((arg1\\*m-arg2\\*m)/m).toFixed(n);&#125; JS乘法函数123456function accMul(arg1,arg2)&#123; var m=0,s1=arg1.toString(),s2=arg2.toString(); try&#123;m+=s1.split(\".\")[1].length&#125;catch(e)&#123;&#125; try&#123;m+=s2.split(\".\")[1].length&#125;catch(e)&#123;&#125; return Number(s1.replace(\".\",\"\"))\\*Number(s2.replace(\".\",\"\"))/Math.pow(10,m)&#125; JS除法函数12345678910function accDiv(arg1,arg2)&#123; var t1=0,t2=0,r1,r2; try&#123;t1=arg1.toString().split(\".\")[1].length&#125;catch(e)&#123;&#125; try&#123;t2=arg2.toString().split(\".\")[1].length&#125;catch(e)&#123;&#125; with(Math)&#123; r1=Number(arg1.toString().replace(\".\",\"\")) r2=Number(arg2.toString().replace(\".\",\"\")) return (r1/r2)\\*pow(10,t2-t1); &#125;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://promix.me/tags/JavaScript/"}]},{"title":"axios 简介","date":"2017-04-03T21:19:59.000Z","path":"2017/axios 简介/","text":"axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 引入方式：123$ npm install axios$ cnpm install axios //taobao源$ bower install axios 或者使用cdn： 1&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 举个栗子：执行 GET 请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345').then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get('/user', &#123; params: &#123; ID: 12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 执行 POST 请求12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone'&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 执行多个并发请求123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125; function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125; axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) &#123; //两个请求现已完成&#125;)); axios API可以通过将相关配置传递给 axios 来进行请求。 12345678910111213axios(config)// 发送一个 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;);axios(url[, config])// 发送一个 GET 请求 (GET请求是默认请求模式)axios('/user/12345'); 请求方法别名为了方便起见，已经为所有支持的请求方法提供了别名。 1234567axios.request（config）axios.get（url [，config]）axios.delete（url [，config]）axios.head（url [，config]）axios.post（url [，data [，config]]）axios.put（url [，data [，config]]）axios.patch（url [，data [，config]]） 注意当使用别名方法时，不需要在config中指定url，method和data属性。 并发帮助函数处理并发请求。 12axios.all（iterable）axios.spread（callback） 创建实例您可以使用自定义配置创建axios的新实例。 1234567axios.create（[config]）var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法可用的实例方法如下所示。 指定的配置将与实例配置合并。 1234567axios#request（config）axios#get（url [，config]）axios#delete（url [，config]）axios#head（url [，config]）axios#post（url [，data [，config]]）axios#put（url [，data [，config]]）axios#patch（url [，data [，config]]） 请求配置这些是用于发出请求的可用配置选项，只有url是必需的，如果未指定方法，请求将默认为GET。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&#123; // `url`是将用于请求的服务器URL url: '/user', // `method`是发出请求时使用的请求方法 method: 'get', // 默认 // `baseURL`将被添加到`url`前面，除非`url`是绝对的。 // 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。 baseURL: 'https://some-domain.com/api/', // `transformRequest`允许在请求数据发送到服务器之前对其进行更改 // 这只适用于请求方法'PUT'，'POST'和'PATCH' // 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream transformRequest: [function (data) &#123; // 做任何你想要的数据转换 return data; &#125;], // `transformResponse`允许在 then / catch之前对响应数据进行更改 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // `headers`是要发送的自定义 headers headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params`是要与请求一起发送的URL参数 // 必须是纯对象或URLSearchParams对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是一个可选的函数，负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data`是要作为请求主体发送的数据 // 仅适用于请求方法“PUT”，“POST”和“PATCH” // 当没有设置`transformRequest`时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream data: &#123; firstName: 'Fred' &#125;, // `timeout`指定请求超时之前的毫秒数。 // 如果请求的时间超过'timeout'，请求将被中止。 timeout: 1000, // `withCredentials`指示是否跨站点访问控制请求 // should be made using credentials withCredentials: false, // default // `adapter'允许自定义处理请求，这使得测试更容易。 // 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api）） adapter: function (config) &#123; /* ... */ &#125;, // `auth'表示应该使用 HTTP 基本认证，并提供凭据。 // 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // “responseType”表示服务器将响应的数据类型 // 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default //`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress`允许处理上传的进度事件 onUploadProgress: function (progressEvent) &#123; // 使用本地 progress 事件做任何你想要做的 &#125;, // `onDownloadProgress`允许处理下载的进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength`定义允许的http响应内容的最大大小 maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise // HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。 // 如果设置为0，则不会遵循重定向。 maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。 // 允许配置类似`keepAlive`的选项， // 默认情况下不启用。 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy'定义代理服务器的主机名和端口 // `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。 // 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // “cancelToken”指定可用于取消请求的取消令牌 // (see Cancellation section below for details) cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 使用 then 时，您将收到如下响应： 12345678axios.get('/user/12345').then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config);&#125;); 配置默认值您可以指定将应用于每个请求的配置默认值。 全局axios默认值： 123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值： 1234567//在创建实例时设置配置默认值var instance = axios.create（&#123; baseURL：'https://api.example.com'&#125;）; //在实例创建后改变默认值instance.defaults.headers.common ['Authorization'] = AUTH_TOKEN; 配置优先级顺序配置将与优先顺序合并。顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数，后者将优先于前者。这里有一个例子： 123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get（'/ longRequest'，&#123; timeout：5000&#125;）; 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前。 1234567891011121314151617//添加请求拦截器axios.interceptors.request.use（function（config）&#123; //在发送请求之前做某事 return config; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; //添加响应拦截器axios.interceptors.response.use（function（response）&#123; //对响应数据做些事 return response; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; 如果你以后可能需要删除拦截器。 12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 你可以将拦截器添加到axios的自定义实例。 12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 处理错误1234567891011121314axios.get（'/ user / 12345'） .catch（function（error）&#123; if（error.response）&#123; //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; &#125; else &#123; //在设置触发错误的请求时发生了错误 console.log（'Error'，error.message）; &#125;&#125; console.log（error.config）; &#125;）; 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。 12345axios.get（'/ user / 12345'，&#123; validateStatus：function（status）&#123; return status &lt; 500; //仅当状态代码大于或等于500时拒绝 &#125;&#125;&#125;） 消除您可以使用取消令牌取消请求。axios cancel token API基于可取消的promise提议，目前处于阶段1。您可以使用CancelToken.source工厂创建一个取消令牌，如下所示： 123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source（）; axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;); //取消请求（消息参数是可选的）source.cancel（'操作被用户取消。'）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（'/ user / 12345'，&#123; cancelToken：new CancelToken（function executor（c）&#123; //一个执行器函数接收一个取消函数作为参数 cancel = c; &#125;）&#125;）; // 取消请求clear(); 注意：您可以使用相同的取消令牌取消几个请求。 使用application / x-www-form-urlencoded格式默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示： 1234var params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。或者，您可以使用qs库对数据进行编码： 12var qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示： 12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;); 你也可以使用qs库。 Promiseaxios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScriptaxios包括TypeScript定义。 12import axios from 'axios';axios.get('/user?ID=12345'); axios在很大程度上受到Angular提供的$http服务的启发。最终，axios努力提供一个在Angular外使用的独立的$http-like服务。环境）。或者，您可以使用qs库对数据进行编码： 12var qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示：12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;); 你也可以使用qs库。 Promiseaxios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScriptaxios包括TypeScript定义。12import axios from 'axios';axios.get('/user?ID=12345'); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://promix.me/tags/JavaScript/"}]},{"title":"Hello World","date":"2017-04-01T10:40:17.000Z","path":"2017/hello-world/","text":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://promix.me/tags/Hexo/"}]}]