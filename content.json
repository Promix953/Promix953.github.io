[{"title":"JS的严格模式","date":"2017-04-10T18:09:24.000Z","path":"2017/04/10/JS的严格模式/","text":"优点 消除JS语法的一些不合理、不严谨之处、减少一些怪异的行为 消除代码运行的一些不安全之处，保证代码运行的安全 提高编译器效率，增加运行效率 为未来新版本的JS做好铺垫 详细 全局变量必须显示声明 123456789101112131415161718 \"use strict\"; v = 1; // 报错，v未声明 ``` * 静态绑定，属性和方法到底归属哪个对象，在编译阶段就确定。提高了编译器的效率 ``` js //禁止使用with语句 因为无法在编译时确定属性归属的对象 \"use strict\"; var v = 1; with (o)&#123; // 语法错误 v = 2; &#125; // 创建了eval作用域正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 \"use strict\"; var x = 2; console.info(eval(\"var x = 5; x\")); // 5 console.info(x); // 2 增强的安全措施 禁止this关键字指向全局对象 123456// 使用构造函数时 如果忘了加new，this不再指向全局对象，而是报错function f() &#123; \"ues strict\"; this.a = 1;&#125;;f(); // 报错，this未定义 禁止在函数内部遍历调用栈 123456function f1() &#123; \"use strict\"; f1.caller; // error f1.arguments; // error &#125; 禁止删除变量 1234567891011// 严格模式下无法删除变量。只用configurable设置为true的对象属性，才能被删除\"use strict\";var x;detele x; //errorvar r = Object.create(null, &#123;'x': &#123; value: 1, configureable: true&#125;&#125;)delete o.x; // delete success 显示报错 1234567891011121314151617181920212223242526272829303132// 正常模式下。对一个对象的只读属性进行赋值，不会报错，会默默的失败，严格模式下，会报错\"use strict\"; var o = &#123;&#125;;Object.defineProperty(o, \"v\", &#123; value: 1, writable: false&#125;);o.v = 2; // error// 严格模式下，对一个使用getter方法读取的属性进行赋值，会报错\"use strict\";var o = &#123; get v() &#123;return 1;&#125;&#125;o.v = 2; // error//严格模式下，对禁止扩展的对象添加新属性，会报错。\"use strict\";var o = &#123;&#125;; Object.preventExtensions(o);o.v = 1; // error //严格模式下，删除一个不可删除的属性，会报错 \"use strict\"; delete Object.prototype; // error 重名错误，对象不能有重名的参数，对象不能有重名的属性 禁止八进制表示法 arguments对象的限制 123456789101112131415// 不允许对arguments赋值// arguments不再追踪参数的变化function f(a) &#123; a = 2; return [a, arguments[0]];&#125; f(1) // 正常模式 [2, 2]function f(a) &#123; \"use strict\"; a = 2; return [a, arguments[0]];&#125; f(1) // 严格模式下 [2, 1]// 禁止使用arguments.callee 函数必须声明在顶层 12345678910// 严格模式只允许在全局作用域或函数作用域的顶层声明函数，也就是说，不允许在非函数的代码块内声明函数\"use strict\";if(true) &#123; function f() &#123; // ...&#125; // error&#125;for(...) &#123; function f() &#123; // ... &#125; // error&#125; * 保留字，使用保留字会报错","tags":[{"name":"notebook","slug":"notebook","permalink":"http://promix953.ml/tags/notebook/"}]},{"title":"关于 JavaScript 的数组随机排序","date":"2017-04-09T19:47:44.000Z","path":"2017/04/09/关于 JavaScript 的数组随机排序/","text":"JavaScript 开发中有时会遇到要将一个数组随机排序（shuffle）的需求，一个常见的写法是这样： 12345function shuffle(arr) &#123; arr.sort(function () &#123; return Math.random() - 0.5; &#125;);&#125; 或者使用更简洁的 ES6 的写法： 123function shuffle(arr) &#123; arr.sort(() =&gt; Math.random() - 0.5);&#125; 我也曾经经常使用这种写法，不久前才意识到，这种写法是有问题的，它并不能真正地随机打乱数组。 问题看下面的代码，我们生成一个长度为 10 的数组[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’, ‘h’, ‘i’, ‘j’]，使用上面的方法将数组乱序，执行多次后，会发现每个元素仍然有很大机率在它原来的位置附近出现。 12345678910let n = 10000;let count = (new Array(10)).fill(0); for (let i = 0; i &lt; n; i ++) &#123; let arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']; arr.sort(() =&gt; Math.random() - 0.5); count[arr.indexOf('a')]++;&#125; console.log(count); 在 Node.JS 6 中执行，输出[ 2891, 2928, 1927, 1125, 579, 270, 151, 76, 34, 19 ]（带有一定随机性，每次结果都不同，但大致分布应该一致），即进行 10000 次排序后，字母’a’（数组中的第一个元素）有约 2891 次出现在第一个位置、2928 次出现在第二个位置，与之对应的只有 19 次出现在最后一个位置。类似地，我们可以算出字母’f’（数组中的第六个元素）在各个位置出现的分布为[ 312, 294, 579, 1012, 1781, 2232, 1758, 1129, 586, 317 ]。如果排序真的是随机的，那么每个元素在每个位置出现的概率都应该一样，实验结果各个位置的数字应该很接近，而不应像现在这样明显地集中在原来位置附近。因此，我们可以认为，使用形如arr.sort(() =&gt; Math.random() - 0.5)这样的方法得到的并不是真正的随机排序。另外，需要注意的是上面的分布仅适用于数组长度不超过 10 的情况，如果数组更长，比如长度为 11，则会是另一种分布。比如： 1234567891011let a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']; // 长度为11let n = 10000;let count = (new Array(a.length)).fill(0); for (let i = 0; i &lt; n; i ++) &#123; let arr = [].concat(a); arr.sort(() =&gt; Math.random() - 0.5); count[arr.indexOf('a')]++;&#125; console.log(count); 在 Node.JS 6 中执行，结果为[ 785, 819, 594, 679, 941, 1067, 932, 697, 624, 986, 1876 ]。分布不同的原因是 v8 引擎中针对短数组和长数组使用了不同的排序方法（下面会讲）。可以看到，两种算法的结果虽然不同，但都明显不够均匀。国外有人写了一个Shuffle算法可视化的页面，在上面可以更直观地看到使用arr.sort(() =&gt; Math.random() - 0.5)的确是很不随机的。 探索看了一下ECMAScript中关于Array.prototype.sort(comparefn)的标准，其中并没有规定具体的实现算法，但是提到一点： Calling comparefn(a,b) always returns the same value v when given a specific pair of values a and b as its two arguments. 也就是说，对同一组a、b的值，comparefn(a, b)需要总是返回相同的值。而上面的() =&gt; Math.random() - 0.5（即(a, b) =&gt; Math.random() - 0.5）显然不满足这个条件。翻看v8引擎数组部分的源码，注意到它出于对性能的考虑，对短数组使用的是插入排序，对长数组则使用了快速排序，至此，也就能理解为什么() =&gt; Math.random() - 0.5并不能真正随机打乱数组排序了。（有一个没明白的地方：源码中说的是对长度小于等于 22 的使用插入排序，大于 22 的使用快排，但实际测试结果显示分界长度是 10。） 解决方案知道问题所在，解决方案也就比较简单了。 方案一既然(a, b) =&gt; Math.random() - 0.5的问题是不能保证针对同一组a、b每次返回的值相同，那么我们不妨将数组元素改造一下，比如将每个元素i改造为： 1234let new_i = &#123; v: i, r: Math.random()&#125;; 即将它改造为一个对象，原来的值存储在键v中，同时给它增加一个键r，值为一个随机数，然后排序时比较这个随机数： 1arr.sort((a, b) =&gt; a.r - b.r); 完整代码如下： 12345678910111213141516function shuffle(arr) &#123; let new_arr = arr.map(i =&gt; (&#123;v: i, r: Math.random()&#125;)); new_arr.sort((a, b) =&gt; a.r - b.r); arr.splice(0, arr.length, ...new_arr.map(i =&gt; i.v));&#125; let a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];let n = 10000;let count = (new Array(a.length)).fill(0); for (let i = 0; i &lt; n; i ++) &#123; shuffle(a); count[a.indexOf('a')]++;&#125; console.log(count); 一次执行结果为：[ 1023, 991, 1007, 967, 990, 1032, 968, 1061, 990, 971 ]。多次验证，同时查看shuffle(arr)函数结果的可视化分布，可以看到，这个方法可以认为足够随机了。 方案二（Fisher–Yates shuffle）需要注意的是，上面的方法虽然满足随机性要求了，但在性能上并不是很好，需要遍历几次数组，还要对数组进行splice等操作。考察Lodash 库中的 shuffle 算法，注意到它使用的实际上是Fisher–Yates 洗牌算法，这个算法由 Ronald Fisher 和 Frank Yates 于 1938 年提出，然后在 1964 年由 Richard Durstenfeld 改编为适用于电脑编程的版本。用伪代码描述如下： 1234-- To shuffle an array a of n elements (indices 0..n-1):for i from n−1 downto 1 do j ← random integer such that 0 ≤ j ≤ i exchange a[j] and a[i] 一个实现如下（ES6）： 1234567function shuffle(arr) &#123; let i = arr.length; while (i) &#123; let j = Math.floor(Math.random() * i--); [arr[j], arr[i]] = [arr[i], arr[j]]; &#125;&#125; 或者对应的 ES5 版本： 123456789function shuffle(arr) &#123; var i = arr.length, t, j; while (i) &#123; j = Math.floor(Math.random() * i--); t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125;&#125; 小结如果要将数组随机排序，千万不要再用(a, b) =&gt; Math.random() - 0.5这样的方法。目前而言，Fisher–Yates shuffle 算法应该是最好的选择。–Yates shuffle 算法应该是最好的选择。","tags":[{"name":"notebook","slug":"notebook","permalink":"http://promix953.ml/tags/notebook/"}]},{"title":"Hello World","date":"2017-04-09T07:30:52.274Z","path":"2017/04/09/hello-world/","text":"hexo测试…","tags":[{"name":"notebook","slug":"notebook","permalink":"http://promix953.ml/tags/notebook/"}]},{"title":"Gox_简单实在的Go平台交叉编译工具","date":"2017-04-08T21:40:59.000Z","path":"2017/04/08/Gox_简单实在的Go平台交叉编译工具/","text":"Gox 是一个简单的，不花俏的Go平台交叉编译工具，它的用处就和标准的 go build 一样。Gox 会并行地为多种平台编译。Gox 同时也提供了一套交叉编译工具链。Gox 项目地址：https://github.com/mitchellh/gox 安装为了安装 Gox，请使用 go get。我们已经为版本打上了标签，所以可以随便切换标签进行编译：1234$ go get github.com/mitchellh/gox...$ gox -h... 用法在你使用 Gox 之前，你必须先有一套交叉编译工具链。Gox 可以自动帮你完成这个。你需要做的只是运行(每次更新 Go 都要这样做这步)：1$ gox -build-toolchain ... 当你完成这个，你可以已经准备好进行交叉编译了。如果你知道怎么去使用 go build, 那么你也知道怎么去使用 Gox 了。例如，编译当前的项目，无需提供参数，只需要调用 gox。Gox 就会根据 CPU 的数量并行地为各个平台编译：1234567891011121314151617$ gox Number of parallel builds: 4--&gt; darwin/386: github.com/mitchellh/gox--&gt; darwin/amd64: github.com/mitchellh/gox--&gt; linux/386: github.com/mitchellh/gox--&gt; linux/amd64: github.com/mitchellh/gox--&gt; linux/arm: github.com/mitchellh/gox--&gt; freebsd/386: github.com/mitchellh/gox--&gt; freebsd/amd64: github.com/mitchellh/gox--&gt; openbsd/386: github.com/mitchellh/gox--&gt; openbsd/amd64: github.com/mitchellh/gox--&gt; windows/386: github.com/mitchellh/gox--&gt; windows/amd64: github.com/mitchellh/gox--&gt; freebsd/arm: github.com/mitchellh/gox--&gt; netbsd/386: github.com/mitchellh/gox--&gt; netbsd/amd64: github.com/mitchellh/gox--&gt; netbsd/arm: github.com/mitchellh/gox--&gt; plan9/386: github.com/mitchellh/gox 或者，你只想编译某个项目和子项目：1$ gox ./... ... 或者，你想仅仅为 linux 编译：1$ gox -os=\"linux\" ... 或者，你仅仅只想为 64 位的 linux 编译：1$ gox -osarch=\"linux/amd64\" ... 还有更多的选项，可以通过 gox -h 查看帮助。 和其他交叉编译工具的比较非常感谢这些工具为我们提供了更多的选择，它们为 go 平台的交叉编译工具提供做了很多方面的贡献. Dave Cheney的交叉编译器： Gox 可以为多种平台编译，所以也能容易地运行在各种 Go 支持的平台上。但Dave的那个需要一个 shell 来运行。Gox 支持并行地编译，但 Dave 的只是按顺序地编译。Gox 也能非常方便地使用的内置的 arch 系统的内置过滤工具。 goxc：它是一个功能丰富的工具，能编译系统项目，上传二进制文件，产生下载页面等；相较之下，Gox 在交叉编译二元文件方面稍稍弱些。但 Gox 能并行地编译项目，而 goxc 不能。Gox 也没有强制指定编译二元文件时输出结果的格式。","tags":[{"name":"notebook","slug":"notebook","permalink":"http://promix953.ml/tags/notebook/"}]},{"title":"JS中浮点数运算不精准","date":"2017-04-03T21:51:41.000Z","path":"2017/04/03/JS中浮点数运算不精准/","text":"Javascript采用了IEEE-745浮点数表示法，这是一种二进制表示法，可以精确地表示分数，比如1/2，1/8，1/1024。遗憾的是，我们常用的分数都是十进制分数1/10，1/100等，二进制浮点数表示法并不能精确的表示类似0.1这样的简单的数字。所以会有js中浮点数运算不精准的问题出现，我们一般会重写js的四则运算。下面主要看看解决js中浮点数运算不精准的具体方法。下面先看看几个JS四则运算的例子，你一定会很惊讶和自己想想的结果不太一样。1234js加法：9.3+0.3;//结果为9.600000000000001js加法：9.3-0.7;//结果为8.600000000000001js乘法：7*0.8;//结果为5.6000000000000005js除法：9.3/0.3;//结果为31.000000000000004 下面看看具体的解决办法，思路就是把浮点数先转换为整数再运算，运算后再对结果转换为小数：JS加法函数12345678function accAdd(arg1,arg2)&#123; var r1,r2,m; try&#123;r1=arg1.toString().split(\".\")[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(\".\")[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)) return (arg1\\*m+arg2\\*m)/m&#125; JS减法函数1234567891011function Subtr(arg1,arg2)&#123; var r1,r2,m,n; try&#123;r1=arg1.toString().split(\".\")[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(\".\")[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)); //动态控制精度长度 n=(r1&gt;=r2)?r1:r2; return ((arg1\\*m-arg2\\*m)/m).toFixed(n);&#125; JS乘法函数123456function accMul(arg1,arg2)&#123; var m=0,s1=arg1.toString(),s2=arg2.toString(); try&#123;m+=s1.split(\".\")[1].length&#125;catch(e)&#123;&#125; try&#123;m+=s2.split(\".\")[1].length&#125;catch(e)&#123;&#125; return Number(s1.replace(\".\",\"\"))\\*Number(s2.replace(\".\",\"\"))/Math.pow(10,m)&#125; JS除法函数12345678910function accDiv(arg1,arg2)&#123; var t1=0,t2=0,r1,r2; try&#123;t1=arg1.toString().split(\".\")[1].length&#125;catch(e)&#123;&#125; try&#123;t2=arg2.toString().split(\".\")[1].length&#125;catch(e)&#123;&#125; with(Math)&#123; r1=Number(arg1.toString().replace(\".\",\"\")) r2=Number(arg2.toString().replace(\".\",\"\")) return (r1/r2)\\*pow(10,t2-t1); &#125;&#125;","tags":[{"name":"notebook","slug":"notebook","permalink":"http://promix953.ml/tags/notebook/"}]},{"title":"axios 简介","date":"2017-04-03T21:19:59.000Z","path":"2017/04/03/axios 简介/","text":"axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 引入方式：123$ npm install axios$ cnpm install axios //taobao源$ bower install axios 或者使用cdn：1&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 举个栗子：执行 GET 请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get('/user?ID=12345').then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get('/user', &#123; params: &#123; ID: 12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 执行 POST 请求12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone'&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 执行多个并发请求123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125; function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125; axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) &#123; //两个请求现已完成&#125;)); axios API可以通过将相关配置传递给 axios 来进行请求。12345678910111213axios(config)// 发送一个 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;);axios(url[, config])// 发送一个 GET 请求 (GET请求是默认请求模式)axios('/user/12345'); 请求方法别名为了方便起见，已经为所有支持的请求方法提供了别名。 1234567axios.request（config）axios.get（url [，config]）axios.delete（url [，config]）axios.head（url [，config]）axios.post（url [，data [，config]]）axios.put（url [，data [，config]]）axios.patch（url [，data [，config]]） 注意当使用别名方法时，不需要在config中指定url，method和data属性。 并发帮助函数处理并发请求。12axios.all（iterable）axios.spread（callback） 创建实例您可以使用自定义配置创建axios的新实例。1234567axios.create（[config]）var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 实例方法可用的实例方法如下所示。 指定的配置将与实例配置合并。1234567axios#request（config）axios#get（url [，config]）axios#delete（url [，config]）axios#head（url [，config]）axios#post（url [，data [，config]]）axios#put（url [，data [，config]]）axios#patch（url [，data [，config]]） 请求配置这些是用于发出请求的可用配置选项。只有url是必需的。如果未指定方法，请求将默认为GET。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&#123; // `url`是将用于请求的服务器URL url: '/user', // `method`是发出请求时使用的请求方法 method: 'get', // 默认 // `baseURL`将被添加到`url`前面，除非`url`是绝对的。 // 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。 baseURL: 'https://some-domain.com/api/', // `transformRequest`允许在请求数据发送到服务器之前对其进行更改 // 这只适用于请求方法'PUT'，'POST'和'PATCH' // 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream transformRequest: [function (data) &#123; // 做任何你想要的数据转换 return data; &#125;], // `transformResponse`允许在 then / catch之前对响应数据进行更改 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // `headers`是要发送的自定义 headers headers: &#123;'X-Requested-With': 'XMLHttpRequest'&#125;, // `params`是要与请求一起发送的URL参数 // 必须是纯对象或URLSearchParams对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是一个可选的函数，负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) &#125;, // `data`是要作为请求主体发送的数据 // 仅适用于请求方法“PUT”，“POST”和“PATCH” // 当没有设置`transformRequest`时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream data: &#123; firstName: 'Fred' &#125;, // `timeout`指定请求超时之前的毫秒数。 // 如果请求的时间超过'timeout'，请求将被中止。 timeout: 1000, // `withCredentials`指示是否跨站点访问控制请求 // should be made using credentials withCredentials: false, // default // `adapter'允许自定义处理请求，这使得测试更容易。 // 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api）） adapter: function (config) &#123; /* ... */ &#125;, // `auth'表示应该使用 HTTP 基本认证，并提供凭据。 // 这将设置一个`Authorization'头，覆盖任何现有的`Authorization'自定义头，使用`headers`设置。 auth: &#123; username: 'janedoe', password: 's00pers3cret' &#125;, // “responseType”表示服务器将响应的数据类型 // 包括 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default //`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress`允许处理上传的进度事件 onUploadProgress: function (progressEvent) &#123; // 使用本地 progress 事件做任何你想要做的 &#125;, // `onDownloadProgress`允许处理下载的进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength`定义允许的http响应内容的最大大小 maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise // HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。 // 如果设置为0，则不会遵循重定向。 maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。 // 允许配置类似`keepAlive`的选项， // 默认情况下不启用。 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 'proxy'定义代理服务器的主机名和端口 // `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。 // 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; &#125;, // “cancelToken”指定可用于取消请求的取消令牌 // (see Cancellation section below for details) cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 使用 then 时，您将收到如下响应：12345678axios.get('/user/12345').then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config);&#125;); 配置默认值您可以指定将应用于每个请求的配置默认值。全局axios默认值123axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值1234567//在创建实例时设置配置默认值var instance = axios.create（&#123; baseURL：'https://api.example.com'&#125;）; //在实例创建后改变默认值instance.defaults.headers.common ['Authorization'] = AUTH_TOKEN; 配置优先级顺序配置将与优先顺序合并。顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数。后者将优先于前者。这里有一个例子：123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get（'/ longRequest'，&#123; timeout：5000&#125;）; 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前1234567891011121314151617//添加请求拦截器axios.interceptors.request.use（function（config）&#123; //在发送请求之前做某事 return config; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; //添加响应拦截器axios.interceptors.response.use（function（response）&#123; //对响应数据做些事 return response; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; 如果你以后可能需要删除拦截器。12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 你可以将拦截器添加到axios的自定义实例。12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 处理错误1234567891011121314axios.get（'/ user / 12345'） .catch（function（error）&#123; if（error.response）&#123; //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; &#125; else &#123; //在设置触发错误的请求时发生了错误 console.log（'Error'，error.message）; &#125;&#125; console.log（error.config）; &#125;）; 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。12345axios.get（'/ user / 12345'，&#123; validateStatus：function（status）&#123; return status &lt; 500; //仅当状态代码大于或等于500时拒绝 &#125;&#125;&#125;） 消除您可以使用取消令牌取消请求。axios cancel token API基于可取消的promise提议，目前处于阶段1。您可以使用CancelToken.source工厂创建一个取消令牌，如下所示：123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source（）; axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;); //取消请求（消息参数是可选的）source.cancel（'操作被用户取消。'）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌：123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（'/ user / 12345'，&#123; cancelToken：new CancelToken（function executor（c）&#123; //一个执行器函数接收一个取消函数作为参数 cancel = c; &#125;）&#125;）; // 取消请求clear(); ++注意：您可以使用相同的取消令牌取消几个请求。++ 使用application / x-www-form-urlencoded格式默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示：1234var params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。或者，您可以使用qs库对数据进行编码：12var qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示：12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;); 你也可以使用qs库。 Promiseaxios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScriptaxios包括TypeScript定义。12import axios from 'axios';axios.get('/user?ID=12345'); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。��环境）。或者，您可以使用qs库对数据进行编码：12var qs = require('qs');axios.post('/foo', qs.stringify(&#123; 'bar': 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示： 12var querystring = require('querystring');axios.post('http://something.com/', querystring.stringify(&#123; foo: 'bar' &#125;); 你也可以使用qs库。 Promiseaxios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScriptaxios包括TypeScript定义。 12import axios from 'axios';axios.get('/user?ID=12345'); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。","tags":[{"name":"notebook","slug":"notebook","permalink":"http://promix953.ml/tags/notebook/"}]}]