[{"title":"Hello World","date":"2017-04-09T06:55:39.307Z","path":"2017/04/09/hello-world/","text":"hexo测试…","tags":[{"name":"notebook","slug":"notebook","permalink":"http://promix953.ml/tags/notebook/"}]},{"title":"JS中浮点数运算不精准","date":"2017-04-03T21:51:41.000Z","path":"2017/04/03/JS中浮点数运算不精准/","text":"Javascript采用了IEEE-745浮点数表示法，这是一种二进制表示法，可以精确地表示分数，比如1/2，1/8，1/1024。遗憾的是，我们常用的分数都是十进制分数1/10，1/100等，二进制浮点数表示法并不能精确的表示类似0.1这样的简单的数字。所以会有js中浮点数运算不精准的问题出现，我们一般会重写js的四则运算。下面主要看看解决js中浮点数运算不精准的具体方法。 下面先看看几个JS四则运算的例子，你一定会很惊讶和自己想想的结果不太一样。js加法：9.3+0.3;//结果为9.600000000000001js加法：9.3-0.7;//结果为8.600000000000001js乘法：7*0.8;//结果为5.6000000000000005js除法：9.3/0.3;//结果为31.000000000000004 下面看看具体的解决办法，思路就是把浮点数先转换为整数再运算，运算后再对结果转换为小数： JS加法函数12345678function accAdd(arg1,arg2)&#123; var r1,r2,m; try&#123;r1=arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)) return (arg1\\*m+arg2\\*m)/m&#125; JS减法函数1234567891011function Subtr(arg1,arg2)&#123; var r1,r2,m,n; try&#123;r1=arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)); //动态控制精度长度 n=(r1&gt;=r2)?r1:r2; return ((arg1\\*m-arg2\\*m)/m).toFixed(n);&#125; JS乘法函数123456function accMul(arg1,arg2)&#123; var m=0,s1=arg1.toString(),s2=arg2.toString(); try&#123;m+=s1.split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125; try&#123;m+=s2.split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125; return Number(s1.replace(&quot;.&quot;,&quot;&quot;))\\*Number(s2.replace(&quot;.&quot;,&quot;&quot;))/Math.pow(10,m)&#125; JS除法函数12345678910function accDiv(arg1,arg2)&#123; var t1=0,t2=0,r1,r2; try&#123;t1=arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125; try&#123;t2=arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125; with(Math)&#123; r1=Number(arg1.toString().replace(&quot;.&quot;,&quot;&quot;)) r2=Number(arg2.toString().replace(&quot;.&quot;,&quot;&quot;)) return (r1/r2)\\*pow(10,t2-t1); &#125;&#125;","tags":[{"name":"notebook","slug":"notebook","permalink":"http://promix953.ml/tags/notebook/"}]},{"title":"axios 简介","date":"2017-04-03T21:19:59.000Z","path":"2017/04/03/axios 简介/","text":"axios 简介axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 引入方式：123$ npm install axios$ cnpm install axios //taobao源$ bower install axios 或者使用cdn： 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 举个栗子：执行 GET 请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get(&apos;/user?ID=12345&apos;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 执行 POST 请求12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 执行多个并发请求123456789101112function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125; function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125; axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) &#123; //两个请求现已完成&#125;)); axios API可以通过将相关配置传递给 axios 来进行请求。12345678910111213axios(config)// 发送一个 POST 请求axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;);axios(url[, config])// 发送一个 GET 请求 (GET请求是默认请求模式)axios(&apos;/user/12345&apos;); 请求方法别名为了方便起见，已经为所有支持的请求方法提供了别名。 1234567axios.request（config）axios.get（url [，config]）axios.delete（url [，config]）axios.head（url [，config]）axios.post（url [，data [，config]]）axios.put（url [，data [，config]]）axios.patch（url [，data [，config]]） 注意当使用别名方法时，不需要在config中指定url，method和data属性。 并发帮助函数处理并发请求。 12axios.all（iterable）axios.spread（callback） 创建实例您可以使用自定义配置创建axios的新实例。 1234567axios.create（[config]）var instance = axios.create(&#123; baseURL: &apos;https://some-domain.com/api/&apos;, timeout: 1000, headers: &#123;&apos;X-Custom-Header&apos;: &apos;foobar&apos;&#125;&#125;); 实例方法可用的实例方法如下所示。 指定的配置将与实例配置合并。 1234567axios＃request（config）axios＃get（url [，config]）axios＃delete（url [，config]）axios＃head（url [，config]）axios＃post（url [，data [，config]]）axios＃put（url [，data [，config]]）axios＃patch（url [，data [，config]]） 请求配置这些是用于发出请求的可用配置选项。只有url是必需的。如果未指定方法，请求将默认为GET。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&#123; // `url`是将用于请求的服务器URL url: &apos;/user&apos;, // `method`是发出请求时使用的请求方法 method: &apos;get&apos;, // 默认 // `baseURL`将被添加到`url`前面，除非`url`是绝对的。 // 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。 baseURL: &apos;https://some-domain.com/api/&apos;, // `transformRequest`允许在请求数据发送到服务器之前对其进行更改 // 这只适用于请求方法&apos;PUT&apos;，&apos;POST&apos;和&apos;PATCH&apos; // 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream transformRequest: [function (data) &#123; // 做任何你想要的数据转换 return data; &#125;], // `transformResponse`允许在 then / catch之前对响应数据进行更改 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // `headers`是要发送的自定义 headers headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;, // `params`是要与请求一起发送的URL参数 // 必须是纯对象或URLSearchParams对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是一个可选的函数，负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;) &#125;, // `data`是要作为请求主体发送的数据 // 仅适用于请求方法“PUT”，“POST”和“PATCH” // 当没有设置`transformRequest`时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream data: &#123; firstName: &apos;Fred&apos; &#125;, // `timeout`指定请求超时之前的毫秒数。 // 如果请求的时间超过&apos;timeout&apos;，请求将被中止。 timeout: 1000, // `withCredentials`指示是否跨站点访问控制请求 // should be made using credentials withCredentials: false, // default // `adapter&apos;允许自定义处理请求，这使得测试更容易。 // 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api）） adapter: function (config) &#123; /* ... */ &#125;, // `auth&apos;表示应该使用 HTTP 基本认证，并提供凭据。 // 这将设置一个`Authorization&apos;头，覆盖任何现有的`Authorization&apos;自定义头，使用`headers`设置。 auth: &#123; username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; &#125;, // “responseType”表示服务器将响应的数据类型 // 包括 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos; responseType: &apos;json&apos;, // default //`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default // `onUploadProgress`允许处理上传的进度事件 onUploadProgress: function (progressEvent) &#123; // 使用本地 progress 事件做任何你想要做的 &#125;, // `onDownloadProgress`允许处理下载的进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength`定义允许的http响应内容的最大大小 maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise // HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。 // 如果设置为0，则不会遵循重定向。 maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。 // 允许配置类似`keepAlive`的选项， // 默认情况下不启用。 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &apos;proxy&apos;定义代理服务器的主机名和端口 // `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。 // 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。 proxy: &#123; host: &apos;127.0.0.1&apos;, port: 9000, auth: : &#123; username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; &#125; &#125;, // “cancelToken”指定可用于取消请求的取消令牌 // (see Cancellation section below for details) cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 使用 then 时，您将收到如下响应： 12345678axios.get(&apos;/user/12345&apos;).then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config);&#125;); 配置默认值您可以指定将应用于每个请求的配置默认值。全局axios默认值 123axios.defaults.baseURL = &apos;https://api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 自定义实例默认值 1234567//在创建实例时设置配置默认值var instance = axios.create（&#123; baseURL：&apos;https://api.example.com&apos;&#125;）; //在实例创建后改变默认值instance.defaults.headers.common [&apos;Authorization&apos;] = AUTH_TOKEN; 配置优先级顺序配置将与优先顺序合并。顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数。后者将优先于前者。这里有一个例子： 123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get（&apos;/ longRequest&apos;，&#123; timeout：5000&#125;）; 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前 1234567891011121314151617//添加请求拦截器axios.interceptors.request.use（function（config）&#123; //在发送请求之前做某事 return config; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; //添加响应拦截器axios.interceptors.response.use（function（response）&#123; //对响应数据做些事 return response; &#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）; &#125;）; 如果你以后可能需要删除拦截器。 12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 123你可以将拦截器添加到axios的自定义实例。var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 处理错误1234567891011121314axios.get（&apos;/ user / 12345&apos;） .catch（function（error）&#123; if（error.response）&#123; //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; &#125; else &#123; //在设置触发错误的请求时发生了错误 console.log（&apos;Error&apos;，error.message）; &#125;&#125; console.log（error.config）; &#125;）; 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。 12345axios.get（&apos;/ user / 12345&apos;，&#123; validateStatus：function（status）&#123; return status &lt; 500; //仅当状态代码大于或等于500时拒绝 &#125;&#125;&#125;） 消除您可以使用取消令牌取消请求。axios cancel token API基于可取消的promise提议，目前处于阶段1。您可以使用CancelToken.source工厂创建一个取消令牌，如下所示： 123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source（）; axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;); //取消请求（消息参数是可选的）source.cancel（&apos;操作被用户取消。&apos;）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（&apos;/ user / 12345&apos;，&#123; cancelToken：new CancelToken（function executor（c）&#123; //一个执行器函数接收一个取消函数作为参数 cancel = c; &#125;）&#125;）; // 取消请求clear(); ++注意：您可以使用相同的取消令牌取消几个请求。++ 使用application / x-www-form-urlencoded格式默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示：1234var params = new URLSearchParams();params.append(&apos;param1&apos;, &apos;value1&apos;);params.append(&apos;param2&apos;, &apos;value2&apos;);axios.post(&apos;/foo&apos;, params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。或者，您可以使用qs库对数据进行编码：12var qs = require(&apos;qs&apos;);axios.post(&apos;/foo&apos;, qs.stringify(&#123; &apos;bar&apos;: 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示： 12var querystring = require(&apos;querystring&apos;);axios.post(&apos;http://something.com/&apos;, querystring.stringify(&#123; foo: &apos;bar&apos; &#125;); 你也可以使用qs库。 Promiseaxios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScriptaxios包括TypeScript定义。 12import axios from &apos;axios&apos;;axios.get(&apos;/user?ID=12345&apos;); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。","tags":[{"name":"notebook","slug":"notebook","permalink":"http://promix953.ml/tags/notebook/"}]}]